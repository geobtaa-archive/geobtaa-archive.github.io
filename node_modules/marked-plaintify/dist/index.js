import { Renderer as x } from "marked";
function g(c = {}) {
  const s = {}, a = ["constructor", "hr", "checkbox", "br", "space"], h = ["strong", "em", "del"], d = ["html", "code"];
  let f = [];
  return Object.getOwnPropertyNames(x.prototype).forEach((t) => {
    a.includes(t) ? s[t] = () => "" : h.includes(t) ? s[t] = function(e) {
      return this.parser.parseInline(e.tokens);
    } : d.includes(t) ? s[t] = (e) => o(e.text) + `

` : t === "codespan" ? s[t] = (e) => o(e.text) : t === "list" ? s[t] = function(e) {
      let n = "";
      for (let i = 0; i < e.items.length; i++) {
        const r = e.items[i], l = this.listitem(r);
        typeof l == "string" && (n += l.replace(/\n{2,}/g, `
`));
      }
      return `
` + n.trim() + `

`;
    } : t === "listitem" ? s[t] = function(e) {
      return `
` + this.parser.parse(e.tokens).trim();
    } : t === "blockquote" ? s[t] = function(e) {
      return this.parser.parse(e.tokens).trim() + `

`;
    } : t === "table" ? s[t] = function(e) {
      f = [];
      for (let i = 0; i < e.header.length; i++)
        this.tablecell(e.header[i]);
      let n = "";
      for (let i = 0; i < e.rows.length; i++) {
        const r = e.rows[i];
        let l = "";
        for (let u = 0; u < r.length; u++)
          l += this.tablecell(r[u]);
        n += this.tablerow({ text: l });
      }
      return n;
    } : t === "tablerow" ? s[t] = (e) => {
      const n = e.text.split("__CELL_PAD__").filter(Boolean);
      return f.map((i, r) => i + ": " + n[r]).join(`
`) + `

`;
    } : t === "tablecell" ? s[t] = function(e) {
      const n = this.parser.parseInline(e.tokens);
      return e.header && f.push(n), n + "__CELL_PAD__";
    } : t === "link" ? s[t] = function(e) {
      return this.parser.parseInline(e.tokens) + `

`;
    } : t === "image" ? s[t] = (e) => e.text + `

` : t === "paragraph" ? s[t] = function(e) {
      let n = this.parser.parseInline(e.tokens);
      return n = n.replace(/\n{2,}/g, ""), n + `

`;
    } : t === "heading" ? s[t] = function(e) {
      return this.parser.parseInline(e.tokens) + `

`;
    } : s[t] = function(e) {
      return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : e.text;
    };
  }), {
    renderer: {
      ...s,
      ...c
    }
  };
}
function o(c) {
  const s = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  return c.replace(/[&<>"']/g, (a) => s[a]);
}
export {
  g as default
};
