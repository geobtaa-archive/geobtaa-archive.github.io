---
// src/components/CsvTable.astro
import { promises as fs } from 'fs';
import path from 'path';
import Papa from 'papaparse';

// Define the component's props. It expects a `src` attribute.
export interface Props {
  src: string;
}

const { src } = Astro.props;

// Construct the absolute path to the CSV file.
// This path is now relative to the project root (e.g., "src/data/my-file.csv").
const csvPath = path.resolve(process.cwd(), src);

let headers: string[] = [];
let rows: string[][] = [];

try {
  // Read the CSV file content at build time.
  const csvContent = await fs.readFile(csvPath, 'utf-8');

  // Use PapaParse to correctly handle complex CSVs, including quoted cells.
  const parseResult = Papa.parse(csvContent, {
    header: true, // Treat the first row as headers
    skipEmptyLines: true,
  });

  if (parseResult.meta.fields) {
    headers = parseResult.meta.fields;
  }

  if (parseResult.data && headers.length > 0) {
    // PapaParse returns an array of objects when header:true.
    // We need to convert it back to an array of arrays (string[][])
    // to match the existing rendering logic.
    rows = (parseResult.data as Record<string, string>[]).map(rowObject => 
      headers.map(header => rowObject[header] || '')
    );
  }

} catch (error) {
  console.error(`Error reading or parsing CSV file at ${csvPath}:`, error);
  // You can render an error message if the file isn't found in production
}
---

{rows.length > 0 && (
  <div class="table-container">
    <table>
      <thead>
        <tr>
          {headers.map(header => <th>{header}</th>)}
        </tr>
      </thead>
      <tbody>
        {rows.map(row => (
          <tr>
            {row.map(cell => <td>{cell}</td>)}
          </tr>
        ))}
      </tbody>
    </table>
  </div>
)}

<style>
  /* Add scoped styles to make the table look good */
  .table-container {
    overflow-x: auto; /* Allows table to be scrolled horizontally on small screens */
    margin-block: 2rem;
    width: 100%;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    border: 1px solid var(--sl-color-hairline);
    font-size: 0.95rem;
  }
  th, td {
    border: 1px solid var(--sl-color-hairline);
    padding: 0.75rem;
    text-align: left;
    font-size: 0.75rem;
    overflow: hidden;
 
    
  }
  thead {
    background-color: var(--sl-color-accent-low);
  }
  th {
    font-weight: 600;
  }
  tbody tr:nth-child(odd) {
    background-color: rgba(120, 120, 120, 0.05);
  }

  /* Dark mode styles */
  [data-theme='dark'] tbody tr:nth-child(odd) {
    background-color: rgba(255, 255, 255, 0.05);
  }
.table {
  width: 100%;
  border-collapse: collapse;
}
.table th, .table td {
  padding: 0.25rem 0.5rem;
  vertical-align: top;
  border-bottom: 1px solid var(--sl-color-hairline);
}
.table td:nth-child(1) {
  font-weight: 600;
  white-space: nowrap;
}
.table td:nth-child(2) {
  width: 40%;
  word-break: break-word;
}
.table td:nth-child(3) {
  width: 30%;
  color: var(--sl-color-text-secondary);
}





</style>