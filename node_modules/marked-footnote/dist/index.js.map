{"version":3,"file":"index.js","sources":["../src/footnote.ts","../src/references.ts","../src/footnotes.ts","../src/index.ts"],"sourcesContent":["import type { TokenizerAndRendererExtension, TokenizerThis } from 'marked'\nimport type { Footnote, Footnotes, LexerTokens } from './types.js'\n\n/**\n * Returns an extension object for parsing footnote definitions.\n */\nexport function createFootnote(lexer: LexerTokens, description: string) {\n  const footnotes: Footnotes = {\n    type: 'footnotes',\n    raw: description,\n    rawItems: [],\n    items: []\n  }\n\n  return {\n    name: 'footnote',\n    level: 'block',\n    childTokens: ['content'],\n    tokenizer(this: TokenizerThis, src: string) {\n      if (!lexer.hasFootnotes) {\n        this.lexer.tokens.push(footnotes)\n\n        lexer.tokens = this.lexer.tokens\n        lexer.hasFootnotes = true\n\n        // always begin with empty items\n        footnotes.rawItems = []\n        footnotes.items = []\n      }\n\n      const match =\n        /^\\[\\^([^\\]\\n]+)\\]:(?:[ \\t]+|[\\n]*?|$)([^\\n]*?(?:\\n|$)(?:\\n*?[ ]{4,}[^\\n]*)*)/.exec(\n          src\n        )\n\n      if (match) {\n        const [raw, label, text = ''] = match\n        let content = text.split('\\n').reduce((acc, curr) => {\n          return acc + '\\n' + curr.replace(/^(?:[ ]{4}|[\\t])/, '')\n        }, '')\n\n        const contentLastLine = content.trimEnd().split('\\n').pop()\n\n        content +=\n          // add lines after list, blockquote, codefence, and table\n          contentLastLine &&\n          /^[ \\t]*?[>\\-*][ ]|[`]{3,}$|^[ \\t]*?[|].+[|]$/.test(contentLastLine)\n            ? '\\n\\n'\n            : ''\n\n        const token: Footnote = {\n          type: 'footnote',\n          raw,\n          label,\n          refs: [],\n          content: this.lexer.blockTokens(content)\n        }\n\n        footnotes.rawItems.push(token)\n\n        return token\n      }\n    },\n    renderer() {\n      // skip it for now!\n      // we will render all `Footnote` through the footnotes renderer\n      return ''\n    }\n  } as TokenizerAndRendererExtension\n}\n","import type { TokenizerAndRendererExtension, TokenizerThis } from 'marked'\nimport type { FootnoteRef, Footnotes } from './types.js'\n\n/**\n * Escapes special HTML characters in a text to be inserted to an element body.\n */\nfunction escapeTextContent(text: string): string {\n  return text\n    .replaceAll('&', '&amp;')\n    .replaceAll('<', '&lt;')\n    .replaceAll('>', '&gt;')\n}\n\n/**\n * Returns an extension object for parsing inline footnote references.\n */\nexport function createFootnoteRef(\n  prefixId: string,\n  refMarkers = false,\n  keepLabels = false\n) {\n  let order = 0\n\n  return {\n    name: 'footnoteRef',\n    level: 'inline',\n    tokenizer(this: TokenizerThis, src: string) {\n      const match = /^\\[\\^([^\\]\\n]+)\\]/.exec(src)\n\n      if (match) {\n        const [raw, label] = match\n        const footnotes = this.lexer.tokens[0] as Footnotes\n        const filteredRawItems = footnotes.rawItems.filter(\n          item => item.label === label\n        )\n\n        if (!filteredRawItems.length) return\n\n        const rawFootnote = filteredRawItems[0]\n        const footnote = footnotes.items.filter(item => item.label === label)[0]\n\n        const ref: FootnoteRef = {\n          type: 'footnoteRef',\n          raw,\n          index: rawFootnote.refs.length,\n          id: '',\n          label\n        }\n\n        if (footnote) {\n          ref.id = footnote.refs[0].id\n          footnote.refs.push(ref)\n        } else {\n          order++\n          ref.id = String(order)\n          rawFootnote.refs.push(ref)\n          footnotes.items.push(rawFootnote)\n        }\n\n        return ref\n      }\n    },\n    renderer({ index, id, label }: FootnoteRef) {\n      order = 0 // reset order\n      const encodedLabel = encodeURIComponent(label)\n      const textLabel = keepLabels ? escapeTextContent(label) : id\n      const idSuffix = index > 0 ? `-${index + 1}` : ''\n\n      return `<sup><a id=\"${prefixId}ref-${encodedLabel}${idSuffix}\" href=\"#${\n        prefixId + encodedLabel\n      }\" data-${prefixId}ref aria-describedby=\"${prefixId}label\">${\n        refMarkers ? `[${textLabel}]` : textLabel\n      }</a></sup>`\n    }\n  } as TokenizerAndRendererExtension\n}\n","import type { RendererExtension, RendererThis } from 'marked'\nimport type { Footnotes } from './types.js'\n\n/**\n * Returns an extension object for rendering the list of footnotes.\n */\nexport function createFootnotes(\n  prefixId: string,\n  prefixData: string,\n  footnoteDivider: boolean,\n  sectionClass: string,\n  headingClass: string,\n  backRefLabel: string\n) {\n  return {\n    name: 'footnotes',\n    renderer(this: RendererThis, { raw, items = [] }: Footnotes) {\n      if (items.length === 0) return ''\n\n      const footnotesItemsHTML = items.reduce(\n        (acc, { label, content, refs }) => {\n          const encodedLabel = encodeURIComponent(label)\n          const parsedContent = this.parser.parse(content).trimEnd()\n          const isEndsWithP = parsedContent.endsWith('</p>')\n\n          let footnoteItem = `<li id=\"${prefixId + encodedLabel}\">\\n`\n          footnoteItem += isEndsWithP\n            ? parsedContent.replace(/<\\/p>$/, '')\n            : parsedContent\n\n          refs.forEach((_, i) => {\n            const ariaLabel = backRefLabel.replace('{0}', label)\n            let textLabel: string\n            let idSuffix: string\n            if (i > 0) {\n              const displayIndex = i + 1\n              textLabel = `↩<sup>${displayIndex}</sup>`\n              idSuffix = `-${displayIndex}`\n            } else {\n              textLabel = '↩'\n              idSuffix = ''\n            }\n            footnoteItem += ` <a href=\"#${prefixId}ref-${encodedLabel}${idSuffix}\" data-${prefixId}backref aria-label=\"${ariaLabel}\">${textLabel}</a>`\n          })\n\n          footnoteItem += isEndsWithP ? '</p>\\n' : '\\n'\n          footnoteItem += '</li>\\n'\n\n          return acc + footnoteItem\n        },\n        ''\n      )\n\n      let footnotesHTML = ''\n      if (footnoteDivider) {\n        footnotesHTML += `<hr data-${prefixData}footnotes>\\n`\n      }\n      let sectionAttrs = ''\n      if (sectionClass) {\n        sectionAttrs = ` class=\"${sectionClass}\"`\n      }\n      let headingAttrs = ''\n      if (headingClass) {\n        headingAttrs = ` class=\"${headingClass}\"`\n      }\n      footnotesHTML += `<section${sectionAttrs} data-${prefixData}footnotes>\\n`\n      footnotesHTML += `<h2 id=\"${prefixId}label\"${headingAttrs}>${raw.trimEnd()}</h2>\\n`\n      footnotesHTML += `<ol>\\n${footnotesItemsHTML}</ol>\\n`\n      footnotesHTML += '</section>\\n'\n\n      return footnotesHTML\n    }\n  } as RendererExtension\n}\n","import type { MarkedExtension } from 'marked'\nimport { createFootnote } from './footnote.js'\nimport { createFootnoteRef } from './references.js'\nimport { createFootnotes } from './footnotes.js'\nimport type { LexerTokens, Options } from './types.js'\n\n/**\n * A [marked](https://marked.js.org/) extension to support [GFM footnotes](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#footnotes).\n */\nexport default function markedFootnote(options: Options = {}): MarkedExtension {\n  const {\n    prefixId = 'footnote-',\n    prefixData = '',\n    description = 'Footnotes',\n    refMarkers = false,\n    footnoteDivider = false,\n    keepLabels = false,\n    sectionClass = 'footnotes',\n    headingClass = 'sr-only',\n    backRefLabel = 'Back to reference {0}'\n  } = options\n  const lexer: LexerTokens = { hasFootnotes: false, tokens: [] }\n\n  return {\n    extensions: [\n      createFootnote(lexer, description),\n      createFootnoteRef(prefixId, refMarkers, keepLabels),\n      createFootnotes(\n        prefixId,\n        prefixData,\n        footnoteDivider,\n        sectionClass,\n        headingClass,\n        backRefLabel\n      )\n    ],\n    walkTokens(token) {\n      if (\n        token.type === 'footnotes' &&\n        lexer.tokens.indexOf(token) === 0 &&\n        token.items.length\n      ) {\n        lexer.tokens[0] = { type: 'space', raw: '' }\n        lexer.tokens.push(token)\n      }\n\n      if (lexer.hasFootnotes) lexer.hasFootnotes = false\n    }\n  }\n}\n\nexport type { Footnote, FootnoteRef, Footnotes, Options } from './types.js'\n"],"names":["createFootnote","lexer","description","footnotes","src","match","raw","label","text","content","acc","curr","contentLastLine","token","escapeTextContent","createFootnoteRef","prefixId","refMarkers","keepLabels","order","filteredRawItems","item","rawFootnote","footnote","ref","index","id","encodedLabel","textLabel","idSuffix","createFootnotes","prefixData","footnoteDivider","sectionClass","headingClass","backRefLabel","items","footnotesItemsHTML","refs","parsedContent","isEndsWithP","footnoteItem","_","i","ariaLabel","displayIndex","footnotesHTML","sectionAttrs","headingAttrs","markedFootnote","options"],"mappings":"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"}