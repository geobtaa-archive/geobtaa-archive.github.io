---
interface Props {
  tags: string[];
  authors: string[];
  years: string[];
  selectedTags: string[];
  selectedAuthors: string[];
  selectedYears: string[];
  context?: string;
  query?: string;
  searchLabel?: string;
  searchPlaceholder?: string;
  tagsLabel?: string;
  authorsEnabled?: boolean;
}

const props = Astro.props as Props;
const {
  tags,
  authors,
  years,
  selectedTags,
  selectedAuthors,
  selectedYears,
  searchLabel,
} = props;

const authorsEnabled = props.authorsEnabled !== false;
const tagsLabel = props.tagsLabel ?? 'Tags';

const context = (() => {
  const base = typeof props.context === 'string' ? props.context.trim().toLowerCase() : 'blog';
  const cleaned = base.replace(/[^a-z0-9_-]/g, '');
  return cleaned.length > 0 ? cleaned : 'blog';
})();

const formId = `${context}-filters`;
const searchInputId = `${context}-filter-search`;
const query = typeof props.query === 'string' ? props.query : '';
const searchPlaceholder = props.searchPlaceholder ?? 'Searchâ€¦';
---

<form
  id={formId}
  method="get"
  class="filter-panel"
  data-filter-context={context}
  data-filter-authors-enabled={authorsEnabled ? 'true' : 'false'}
>
  {searchLabel && (
    <div class="filter-panel__search">
      <label class="filter-panel__search-label" for={searchInputId}>
        {searchLabel}
      </label>
      <input
        type="search"
        id={searchInputId}
        name="q"
        value={query}
        placeholder={searchPlaceholder}
        class="filter-panel__search-input"
        autocomplete="off"
        spellcheck="false"
      />
    </div>
  )}

{authorsEnabled && authors.length > 0 && (
  <details class="filter-panel__section" data-filter-section="authors" open={selectedAuthors.length > 0}>
    <summary class="filter-panel__summary">
      <span>Authors</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="authors"
        hidden={selectedAuthors.length === 0}
      >
        {selectedAuthors.length > 0 ? selectedAuthors.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options">
      {authors.map((author) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="author"
            value={author}
            checked={selectedAuthors.includes(author)}
          />
          {author}
        </label>
      ))}
    </div>
  </details>
)}

{years.length > 0 && (
  <details class="filter-panel__section" data-filter-section="years" open={selectedYears.length > 0}>
    <summary class="filter-panel__summary">
      <span>Years</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="years"
        hidden={selectedYears.length === 0}
      >
        {selectedYears.length > 0 ? selectedYears.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options filter-panel__options--inline">
      {years.map((year) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="year"
            value={String(year)}
            checked={selectedYears.includes(String(year))}
          />
          {year}
        </label>
      ))}
    </div>
  </details>
)}

{tags.length > 0 && (
  <details class="filter-panel__section" data-filter-section="tags" open={selectedTags.length > 0}>
    <summary class="filter-panel__summary">
      <span>{tagsLabel}</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="tags"
        hidden={selectedTags.length === 0}
      >
        {selectedTags.length > 0 ? selectedTags.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options">
      {tags.map((tag) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="tag"
            value={tag}
            checked={selectedTags.includes(tag)}
          />
          {tag}
        </label>
      ))}
    </div>
  </details>
)}
</form>

<script type="module" is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    const forms = document.querySelectorAll('form[data-filter-context]');
    forms.forEach((form) => {
      if (!(form instanceof HTMLFormElement)) return;
      if (form.dataset.filterReady === 'true') return;

      const context = form.dataset.filterContext ?? 'blog';
      const grid = document.querySelector(`[data-${context}-grid]`);
      const emptyState = document.querySelector(`[data-${context}-empty]`);
      const authorsEnabled = form.dataset.filterAuthorsEnabled !== 'false';

      if (!grid) {
        form.addEventListener('submit', (event) => event.preventDefault());
        return;
      }

      form.dataset.filterReady = 'true';

      /**
       * @typedef {{ tags: string[]; authors: string[]; years: string[]; sort: 'newest' | 'oldest'; query: string }} Selection
       * @typedef {{ element: HTMLElement; tags: string[]; authors: string[]; year: string; dateValue: number; order: number; searchIndex: string }} Card
       */

      /**
       * @param {string} value
       * @returns {string[]}
       */
      const safeParseStringArray = (value) => {
        try {
          const parsed = JSON.parse(value);
          if (Array.isArray(parsed)) {
            return parsed.map((item) => String(item).trim()).filter(Boolean);
          }
        } catch {
          // ignore
        }
        return [];
      };

      form.addEventListener('submit', (event) => event.preventDefault());

      /** @type {HTMLElement[]} */
      const cardElements = Array.from(grid.querySelectorAll(`[data-${context}-card]`));
      /** @type {Card[]} */
      const cards = cardElements.map((element, index) => {
        const dataset = element.dataset;
        const rawTags = dataset.tags ?? '[]';
        const rawAuthors = dataset.authors ?? '[]';
        const year = dataset.year ?? '';
        const dateValue = Number(dataset.date ?? '0');
        const order = Number(dataset.index ?? String(index));
        const datasetSearch = dataset.search ?? '';
        const searchIndex =
          datasetSearch !== ''
            ? String(datasetSearch).toLowerCase()
            : (element.textContent ?? '').toLowerCase();

        return {
          element,
          tags: safeParseStringArray(rawTags),
          authors: safeParseStringArray(rawAuthors),
          year: year ? String(year) : '',
          dateValue: Number.isNaN(dateValue) ? 0 : dateValue,
          order: Number.isNaN(order) ? index : order,
          searchIndex,
        };
      });

      /**
       * @param {Selection} selection
       */
      const updateCountBadges = (selection) => {
        /** @type {Array<[string, number]>} */
        const entries = [
          ['tags', selection.tags.length],
          ['years', selection.years.length],
        ];

        if (authorsEnabled) {
          entries.splice(1, 0, ['authors', selection.authors.length]);
        }

        entries.forEach(([key, count]) => {
          const badge = form.querySelector(`[data-filter-count="${key}"]`);
          if (badge instanceof HTMLElement) {
            badge.textContent = count ? String(count) : '';
            badge.hidden = count === 0;
          }
        });
      };

      const normaliseQuery = (value) =>
        typeof value === 'string' ? value.trim().toLowerCase() : '';

      const applySelection = (selection) => {
        const { tags, authors, years, sort, query } = selection;
        const sortMultiplier = sort === 'oldest' ? 1 : -1;
        const queryNeedle = normaliseQuery(query);

        const sortedCards = [...cards].sort((a, b) => {
          const dateDiff = (a.dateValue - b.dateValue) * sortMultiplier;
          if (dateDiff !== 0) return dateDiff;
          return a.order - b.order;
        });

        sortedCards.forEach(({ element }) => {
          grid.appendChild(element);
        });

        let visibleCount = 0;

        cards.forEach((card) => {
          const tagMatch =
            tags.length === 0 ||
            tags.every((tag) => card.tags.includes(tag));
          const authorMatch =
            !authorsEnabled ||
            authors.length === 0 ||
            authors.every((author) => card.authors.includes(author));
          const yearMatch =
            years.length === 0 ||
            (card.year !== '' && years.includes(card.year));
          const queryMatch =
            queryNeedle === '' || (card.searchIndex && card.searchIndex.includes(queryNeedle));

          const isVisible = tagMatch && authorMatch && yearMatch && queryMatch;
          card.element.style.display = isVisible ? '' : 'none';

          if (isVisible) {
            visibleCount += 1;
          }
        });

        if (emptyState) {
          emptyState.hidden = visibleCount !== 0;
        }

        updateCountBadges(selection);
      };

      /**
       * @param {URLSearchParams} params
       * @returns {Selection}
       */
      const selectionFromParams = (params) => ({
        tags: params.getAll('tag').map((value) => value.trim()).filter(Boolean),
        authors: authorsEnabled
          ? params.getAll('author').map((value) => value.trim()).filter(Boolean)
          : [],
        years: params.getAll('year').map((value) => value.trim()).filter(Boolean),
        sort: params.get('sort') === 'oldest' ? 'oldest' : 'newest',
        query: params.get('q')?.trim() ?? '',
      });

      /**
       * @param {Selection} selection
       * @returns {URLSearchParams}
       */
      const paramsFromSelection = (selection) => {
        const params = new URLSearchParams();
        selection.tags.forEach((value) => params.append('tag', value));
        if (authorsEnabled) {
          selection.authors.forEach((value) => params.append('author', value));
        }
        selection.years.forEach((value) => params.append('year', value));
        if (selection.sort === 'oldest') {
          params.set('sort', 'oldest');
        } else {
          params.delete('sort');
        }
        if (selection.query.trim()) {
          params.set('q', selection.query.trim());
        } else {
          params.delete('q');
        }
        return params;
      };

      /**
       * @param {Selection} selection
       */
      const populateFormFromSelection = (selection) => {
        const tagInputs = form.querySelectorAll('input[type="checkbox"][name="tag"]');
        tagInputs.forEach((input) => {
          if (input instanceof HTMLInputElement) {
            input.checked = selection.tags.includes(input.value);
          }
        });

        if (authorsEnabled) {
          const authorInputs = form.querySelectorAll('input[type="checkbox"][name="author"]');
          authorInputs.forEach((input) => {
            if (input instanceof HTMLInputElement) {
              input.checked = selection.authors.includes(input.value);
            }
          });
        }

        const yearInputs = form.querySelectorAll('input[type="checkbox"][name="year"]');
        yearInputs.forEach((input) => {
          if (input instanceof HTMLInputElement) {
            input.checked = selection.years.includes(input.value);
          }
        });

        const sortInputs = form.querySelectorAll('input[type="radio"][name="sort"]');
        sortInputs.forEach((input) => {
          if (input instanceof HTMLInputElement) {
            input.checked = input.value === selection.sort;
          }
        });

        const searchInput = form.querySelector('input[type="search"][name="q"]');
        if (searchInput instanceof HTMLInputElement) {
          searchInput.value = selection.query;
        }
      };

      /**
       * @returns {Selection}
       */
      const selectionFromForm = () => {
        const data = new FormData(form);
        return {
          tags: data.getAll('tag').map((value) => String(value).trim()).filter(Boolean),
          authors: authorsEnabled
            ? data.getAll('author').map((value) => String(value).trim()).filter(Boolean)
            : [],
          years: data.getAll('year').map((value) => String(value).trim()).filter(Boolean),
          sort: data.get('sort') === 'oldest' ? 'oldest' : 'newest',
          query: String(data.get('q') ?? '').trim(),
        };
      };

      /**
       * @param {Selection} selection
       */
      const updateView = (selection) => {
        applySelection(selection);
        const params = paramsFromSelection(selection);
        const queryString = params.toString();
        const newUrl = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
        window.history.replaceState(null, '', newUrl);
      };

      const initialise = () => {
        const initialSelection = selectionFromParams(new URLSearchParams(window.location.search));
        populateFormFromSelection(initialSelection);
        updateView(initialSelection);
      };

      initialise();

      const emitUpdate = () => {
        const selection = selectionFromForm();
        updateView(selection);
      };

      form.addEventListener('change', emitUpdate);

      form.addEventListener('input', (event) => {
        if (!(event.target instanceof HTMLInputElement)) return;
        if (event.target.name === 'q') {
          emitUpdate();
        }
      });

      const resetButtons = document.querySelectorAll(`[data-filter-reset="${context}"]`);
      resetButtons.forEach((button) => {
        if (!(button instanceof HTMLButtonElement)) return;
        button.addEventListener('click', () => {
          form.reset();
          /** @type {Selection} */
          const defaultSelection = {
            tags: [],
            authors: [],
            years: [],
            sort: 'newest',
            query: '',
          };
          populateFormFromSelection(defaultSelection);
          updateView(defaultSelection);
        });
      });
    });
  });
</script>

<style>
  .filter-panel__search {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }

  .filter-panel__search-label {
    font-weight: 600;
    font-size: 0.9rem;
    color: var(--sl-color-text);
  }

  .filter-panel__search-input {
    padding: 0.45rem 0.65rem;
    border-radius: 0.5rem;
    border: 1px solid var(--sl-color-hairline);
    background: var(--sl-color-bg);
    font: inherit;
    color: inherit;
  }

  .filter-panel__search-input:focus-visible {
    outline: 2px solid var(--sl-color-primary);
    outline-offset: 2px;
  }

  .filter-panel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 0.75rem;
    background: var(--sl-color-bg-soft);
  }

  .filter-panel__options {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .filter-panel__options--inline {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 0.35rem 0.5rem;
  }

  .filter-panel__section {
    padding: 0.05rem 0 0.45rem;
  }

  .filter-panel__section + .filter-panel__section {
    margin-top: 0.4rem;
  }

  .filter-panel__summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.6rem;
    padding: 0.3rem 0.15rem;
    cursor: pointer;
    font-weight: 600;
    list-style: none;
  }

  .filter-panel__summary::-webkit-details-marker,
  .filter-panel__summary::marker {
    display: none;
  }

  .filter-panel__summary::after {
    content: '';
    flex-shrink: 0;
    width: 0.65rem;
    height: 0.65rem;
    border-right: 2px solid currentColor;
    border-bottom: 2px solid currentColor;
    transform: rotate(-45deg);
    transition: transform 150ms ease;
  }

  .filter-panel__section[open] .filter-panel__summary::after {
    transform: rotate(45deg);
  }

  .filter-panel__summary-count {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 1.3rem;
    height: 1.3rem;
    border-radius: 999px;
    background: var(--sl-color-bg-soft);
    color: var(--sl-color-text-muted);
    font-size: 0.7rem;
    font-weight: 600;
  }

  .filter-panel__section[open] .filter-panel__summary {
    border-bottom: 1px solid var(--sl-color-hairline);
    margin-bottom: 0.3rem;
    padding-bottom: 0.3rem;
  }

  .filter-panel__option {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    font-size: 0.9rem;
    color: var(--sl-color-text);
  }

  .filter-panel__option input {
    accent-color: var(--sl-color-primary);
  }

</style>
