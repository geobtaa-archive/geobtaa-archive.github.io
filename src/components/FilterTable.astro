---
import { promises as fs } from "fs";
import path from "path";
import Papa from "papaparse";

/** Column config */
export interface Column {
  key: string;
  label?: string;
  width?: string;
  filter?: "text" | "datalist" | false;
  clampLines?: number;
  wrap?: "normal" | "nowrap";
}


/** Props */
export interface Props {
  /** Preferred: root-relative path like "src/tables/your.csv" */
  src?: string;
  /** OR pass CSV text that was imported with ?raw */
  rawCsv?: string;
  /** OR already-parsed rows */
  data?: Record<string, any>[];
  /** Optional explicit columns; otherwise inferred from CSV headers */
  columns?: Column[];
  id?: string;
  striped?: boolean;
}

const {
  src,
  rawCsv,
  data: dataProp,
  columns: columnsProp,
  id = "ft",
  striped = true,
} = Astro.props;

/* ---------- Load & parse rows (build-time) ---------- */
let rows: Record<string, any>[] = [];

if (Array.isArray(dataProp) && dataProp.length) {
  // Already-parsed data from MDX
  rows = dataProp;
} else if (typeof rawCsv === "string") {
  // CSV text provided (e.g., import '...csv?raw')
  const parsed = Papa.parse<Record<string, string>>(rawCsv, {
    header: true,
    skipEmptyLines: true,
  });
  rows = (parsed.data ?? []).map((r) => {
    const out: Record<string, string> = {};
    for (const [k, v] of Object.entries(r)) out[k] = (v ?? "").toString().trim();
    return out;
  });
} else if (typeof src === "string" && src.length) {
  // Read from disk using project root (matches your working CsvTable.astro)
  const csvPath = path.resolve(process.cwd(), src);
  const csvContent = await fs.readFile(csvPath, "utf-8");
  const parsed = Papa.parse<Record<string, string>>(csvContent, {
    header: true,
    skipEmptyLines: true,
  });
  rows = (parsed.data ?? []).map((r) => {
    const out: Record<string, string> = {};
    for (const [k, v] of Object.entries(r)) out[k] = (v ?? "").toString().trim();
    return out;
  });
} else {
  rows = [];
}

/* ---------- Infer columns if not provided ---------- */
const csvHeaders = rows.length ? Object.keys(rows[0]) : [];
const columns: Column[] =
  columnsProp && columnsProp.length
    ? columnsProp
    : csvHeaders.map((h) => ({ key: h, label: h }));

/* ---------- Build datalist options ---------- */
const datalistOptions: Record<string, string[]> = {};
for (const col of columns) {
  if (col.filter === "datalist") {
    const uniq = new Set<string>();
    for (const r of rows) {
      const v = (r[col.key] ?? "").toString().trim();
      if (v) uniq.add(v);
    }
    datalistOptions[col.key] = Array.from(uniq).sort((a, b) => a.localeCompare(b));
  }
}

/* ---------- Helpers ---------- */
const safeId = (s: string) =>
  s.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") || "col";

const cellClass = (col: Column) => {
  const parts = ["cell"];
  if (col.wrap === "nowrap") parts.push("nowrap");
  if (typeof col.clampLines === "number") parts.push(`clamp-${col.clampLines}`);
  return parts.join(" ");
};
---


<div class="table-wrap" data-id={id}>
  <div class="table-tools">
    <div class="count" id={`${id}-count`} aria-live="polite">
      Showing {rows.length} of {rows.length}
    </div>
    <button class="reset" id={`${id}-reset`} type="button">Reset filters</button>
  </div>

  <table class={`table ${striped ? 'striped' : ''}`} id={`${id}-table`}>
    <thead>
      <!-- filter row -->
      <tr class="filters">
        {columns.map((col, idx) => {
          const sid = `${id}-f-${safeId(col.key)}-${idx}`;
          return (
            <th style={col.width ? `width:${col.width}` : undefined}>
              {col.filter !== false ? (
                col.filter === "datalist" ? (
                  <>
                    <label class="visually-hidden" for={sid}>Filter {col.label ?? col.key}</label>
                    <input id={sid} data-col={col.key} type="text" placeholder="Filter…" list={`${id}-list-${safeId(col.key)}-${idx}`} />
                    <datalist id={`${id}-list-${safeId(col.key)}-${idx}`}>
                      {(datalistOptions[col.key] ?? []).map((opt) => <option value={opt}></option>)}
                    </datalist>
                  </>
                ) : (
                  <>
                    <label class="visually-hidden" for={sid}>Filter {col.label ?? col.key}</label>
                    <input id={sid} data-col={col.key} type="text" placeholder="Filter…" />
                  </>
                )
              ) : null}
            </th>
          );
        })}
      </tr>

      <!-- header row -->
      <tr class="head">
        {columns.map((col) => (
          <th scope="col" style={col.width ? `width:${col.width}` : undefined}>
            {col.label ?? col.key}
          </th>
        ))}
      </tr>
    </thead>

    <tbody>
      {rows.map((row) => (
        <tr>
          {columns.map((col) => (
            <td
              data-key={col.key}               /* uses header text as-is */
              class={cellClass(col)}
              style={col.width ? `width:${col.width}` : undefined}
              title={(row[col.key] ?? "").toString()}
            >
              {(row[col.key] ?? "").toString()}
            </td>
          ))}
        </tr>
      ))}
    </tbody>
  </table>
</div>

<script>
(() => {
  const wrap = document.querySelector('.table-wrap[data-id]');
  if (!wrap) return;
  const id = wrap.getAttribute('data-id');
  const table = document.getElementById(id + '-table');
  if (!table) return;

  const inputs = table.querySelectorAll('thead .filters input');
  const rows = Array.from(table.querySelectorAll('tbody tr'));
  const countEl = document.getElementById(id + '-count');
  const resetBtn = document.getElementById(id + '-reset');

  const normalize = (s) => (s || '').toString().toLowerCase();

  const filter = () => {
    const filters = {};
    inputs.forEach((inp) => {
      const val = normalize(inp.value);
      if (val) filters[inp.dataset.col] = val; // dataset.col holds the ORIGINAL header text
    });

    let visible = 0;
    rows.forEach((tr) => {
      let keep = true;
      for (const [col, needle] of Object.entries(filters)) {
        // Match by original header text stored in data-key
        const cell = tr.querySelector(`[data-key="${CSS.escape(col)}"]`);
        const hay = normalize(cell?.textContent || '');
        if (!hay.includes(needle)) { keep = false; break; }
      }
      tr.style.display = keep ? '' : 'none';
      if (keep) visible++;
    });

    if (countEl) countEl.textContent = `Showing ${visible} of ${rows.length}`;
  };

  let t;
  inputs.forEach((inp) => {
    inp.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(filter, 80);
    });
  });

  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      inputs.forEach((i) => (i.value = ''));
      filter();
    });
  }
})();
</script>
