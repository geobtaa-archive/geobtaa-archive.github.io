---
import { promises as fs } from "fs";
import path from "path";
import Papa from "papaparse";

/** Column config */
export interface Column {
  key: string;
  label?: string;
  width?: string;
  filter?: "text" | "datalist" | false;
  clampLines?: number;
  wrap?: "normal" | "nowrap";
}

/** Props */
export interface Props {
  /** Preferred: root-relative path like "src/tables/your.csv" */
  src?: string;
  /** OR pass CSV text that was imported with ?raw */
  rawCsv?: string;
  /** OR already-parsed rows */
  data?: Record<string, any>[];
  /** Optional explicit columns; otherwise inferred from CSV headers */
  columns?: Column[];
  id?: string;
  striped?: boolean;
}

const {
  src,
  rawCsv,
  data: dataProp,
  columns: columnsProp,
  id = "ft",
  striped = true,
} = Astro.props;

/* ---------- Load & parse rows (build-time) ---------- */
let rows: Record<string, any>[] = [];

if (Array.isArray(dataProp) && dataProp.length) {
  // Already-parsed data from MDX
  rows = dataProp;
} else if (typeof rawCsv === "string") {
  // CSV text provided (e.g., import '...csv?raw')
  const parsed = Papa.parse<Record<string, string>>(rawCsv, {
    header: true,
    skipEmptyLines: true,
  });
  rows = (parsed.data ?? []).map((r) => {
    const out: Record<string, string> = {};
    for (const [k, v] of Object.entries(r)) out[k] = (v ?? "").toString().trim();
    return out;
  });
} else if (typeof src === "string" && src.length) {
  // Read from disk using project root (matches your working CsvTable.astro)
  const csvPath = path.resolve(process.cwd(), src);
  const csvContent = await fs.readFile(csvPath, "utf-8");
  const parsed = Papa.parse<Record<string, string>>(csvContent, {
    header: true,
    skipEmptyLines: true,
  });
  rows = (parsed.data ?? []).map((r) => {
    const out: Record<string, string> = {};
    for (const [k, v] of Object.entries(r)) out[k] = (v ?? "").toString().trim();
    return out;
  });
} else {
  rows = [];
}

/* ---------- Infer columns if not provided ---------- */
const csvHeaders = rows.length ? Object.keys(rows[0]) : [];
const columns: Column[] =
  columnsProp && columnsProp.length
    ? columnsProp
    : csvHeaders.map((h) => ({ key: h, label: h }));

/* ---------- Build datalist options ---------- */
const datalistOptions: Record<string, string[]> = {};
for (const col of columns) {
  if (col.filter === "datalist") {
    const uniq = new Set<string>();
    for (const r of rows) {
      const v = (r[col.key] ?? "").toString().trim();
      if (v) uniq.add(v);
    }
    datalistOptions[col.key] = Array.from(uniq).sort((a, b) => a.localeCompare(b));
  }
}

/* ---------- Helpers ---------- */
const safeId = (s: string) =>
  s.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "") || "col";

const cellClass = (col: Column) => {
  const parts = ["cell"];
  if (col.wrap === "nowrap") parts.push("nowrap");
  if (typeof col.clampLines === "number") parts.push(`clamp-${col.clampLines}`);
  return parts.join(" ");
};
---


<div class="table-wrap" data-id={id}>
  <div class="table-tools">
    <div class="count" id={`${id}-count`} aria-live="polite">
      Showing {rows.length} of {rows.length}
    </div>
    <button class="reset" id={`${id}-reset`} type="button">Reset filters</button>
  </div>

  <table class={`people-table ${striped ? 'striped' : ''}`} id={`${id}-table`}>
    <thead>
      <!-- filter row -->
      <tr class="filters">
        {columns.map((col, idx) => {
          const sid = `${id}-f-${safeId(col.key)}-${idx}`;
          return (
            <th style={col.width ? `width:${col.width}` : undefined}>
              {col.filter !== false ? (
                col.filter === "datalist" ? (
                  <>
                    <label class="visually-hidden" for={sid}>Filter {col.label ?? col.key}</label>
                    <input id={sid} data-col={col.key} type="text" placeholder="Filter…" list={`${id}-list-${safeId(col.key)}-${idx}`} />
                    <datalist id={`${id}-list-${safeId(col.key)}-${idx}`}>
                      {(datalistOptions[col.key] ?? []).map((opt) => <option value={opt}></option>)}
                    </datalist>
                  </>
                ) : (
                  <>
                    <label class="visually-hidden" for={sid}>Filter {col.label ?? col.key}</label>
                    <input id={sid} data-col={col.key} type="text" placeholder="Filter…" />
                  </>
                )
              ) : null}
            </th>
          );
        })}
      </tr>

      <!-- header row -->
      <tr class="head">
        {columns.map((col) => (
          <th scope="col" style={col.width ? `width:${col.width}` : undefined}>
            {col.label ?? col.key}
          </th>
        ))}
      </tr>
    </thead>

    <tbody>
      {rows.map((row) => (
        <tr>
          {columns.map((col) => (
            <td
              data-key={col.key}               /* uses header text as-is */
              class={cellClass(col)}
              style={col.width ? `width:${col.width}` : undefined}
              title={(row[col.key] ?? "").toString()}
            >
              {(row[col.key] ?? "").toString()}
            </td>
          ))}
        </tr>
      ))}
    </tbody>
  </table>
</div>

<script>
(() => {
  const wrap = document.querySelector('.table-wrap[data-id]');
  if (!wrap) return;
  const id = wrap.getAttribute('data-id');
  const table = document.getElementById(id + '-table');
  if (!table) return;

  const inputs = table.querySelectorAll('thead .filters input');
  const rows = Array.from(table.querySelectorAll('tbody tr'));
  const countEl = document.getElementById(id + '-count');
  const resetBtn = document.getElementById(id + '-reset');

  const normalize = (s) => (s || '').toString().toLowerCase();

  const filter = () => {
    const filters = {};
    inputs.forEach((inp) => {
      const val = normalize(inp.value);
      if (val) filters[inp.dataset.col] = val; // dataset.col holds the ORIGINAL header text
    });

    let visible = 0;
    rows.forEach((tr) => {
      let keep = true;
      for (const [col, needle] of Object.entries(filters)) {
        // Match by original header text stored in data-key
        const cell = tr.querySelector(`[data-key="${CSS.escape(col)}"]`);
        const hay = normalize(cell?.textContent || '');
        if (!hay.includes(needle)) { keep = false; break; }
      }
      tr.style.display = keep ? '' : 'none';
      if (keep) visible++;
    });

    if (countEl) countEl.textContent = `Showing ${visible} of ${rows.length}`;
  };

  let t;
  inputs.forEach((inp) => {
    inp.addEventListener('input', () => {
      clearTimeout(t);
      t = setTimeout(filter, 80);
    });
  });

  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      inputs.forEach((i) => (i.value = ''));
      filter();
    });
  }
})();
</script>

<style>
.table-wrap {
  margin-block: 1rem 1.5rem;
  overflow-x: auto;
  background: var(--sl-color-bg);
  border: 1px solid var(--sl-color-hairline);
}

.table-tools {
  display: flex; justify-content: space-between; align-items: center; gap: .5rem;
  padding: .5rem .75rem;
  border-bottom: 1px solid var(--sl-color-hairline);
  background: var(--sl-color-bg-alt);
  border-top-left-radius: .75rem; border-top-right-radius: .75rem;
}
.count { font-size: 0.875rem; color: var(--sl-color-text-secondary); }
.reset {
  font: inherit; padding: .25rem .5rem; border-radius: .5rem;
  border: 1px solid var(--sl-color-hairline); background: transparent; cursor: pointer;
}
.reset:hover { background: var(--sl-color-bg); }

.people-table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
}
.people-table thead th { position: sticky; top: 0; background: var(--sl-color-bg); z-index: 1; }
.people-table thead .head { background: var(--sl-color-bg-alt); }
.people-table th, .people-table td {
  padding: .45rem .6rem;
  border-bottom: 1px solid var(--sl-color-hairline);
  vertical-align: top;
  font-family: "Inter", "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 0.8rem;
  line-height: 1.35;
  letter-spacing: 0.01em;
}

.people-table thead .filters th { background: var(--sl-color-bg-alt); border-bottom-color: var(--sl-color-hairline); }
.people-table thead .filters input {
  width: 100%; padding: .35rem .45rem; font: inherit;
  border: 1px solid var(--sl-color-hairline); border-radius: .4rem; background: var(--sl-color-bg);
}

.people-table.striped tbody tr:nth-child(even) { background: var(--sl-rows); }
.people-table.striped tbody tr:nth-child(odd)  { background: var(--sl-color-bg); }
.people-table tbody tr:hover {
  background: color-mix(in srgb, var(--sl-color-primary) 10%, var(--sl-color-bg));
  transition: background-color 0.15s ease;
}


/* Optional: make header slightly stronger */
.people-table th {
  font-weight: 600;
  text-transform: none;
  letter-spacing: 0;
}


/* Wrapping & clamping */
.cell { white-space: normal; word-wrap: break-word; overflow-wrap: break-word; hyphens: auto; }
.cell.nowrap { white-space: nowrap; text-overflow: ellipsis; overflow: hidden; }
.cell.clamp-2, .cell.clamp-3, .cell.clamp-4 {
  display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden;
}
.cell.clamp-2 { -webkit-line-clamp: 2; }
.cell.clamp-3 { -webkit-line-clamp: 3; }
.cell.clamp-4 { -webkit-line-clamp: 4; }
.visually-hidden {
  position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
  overflow: hidden; clip: rect(0 0 0 0); white-space: nowrap; border: 0;
}
</style>
