---
interface Props {
  tags: string[];
  authors: string[];
  years: number[];
  selectedTags: string[];
  selectedAuthors: string[];
  selectedYears: string[];
}

const {
  tags,
  authors,
  years,
  selectedTags,
  selectedAuthors,
  selectedYears,
} = Astro.props as Props;
---

<form id="blog-filters" method="get" class="filter-panel">

{tags.length > 0 && (
  <details class="filter-panel__section" data-filter-section="tags" open={selectedTags.length > 0}>
    <summary class="filter-panel__summary">
      <span>Tags</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="tags"
        hidden={selectedTags.length === 0}
      >
        {selectedTags.length > 0 ? selectedTags.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options">
      {tags.map((tag) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="tag"
            value={tag}
            checked={selectedTags.includes(tag)}
          />
          {tag}
        </label>
      ))}
    </div>
  </details>
)}

{authors.length > 0 && (
  <details class="filter-panel__section" data-filter-section="authors" open={selectedAuthors.length > 0}>
    <summary class="filter-panel__summary">
      <span>Authors</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="authors"
        hidden={selectedAuthors.length === 0}
      >
        {selectedAuthors.length > 0 ? selectedAuthors.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options">
      {authors.map((author) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="author"
            value={author}
            checked={selectedAuthors.includes(author)}
          />
          {author}
        </label>
      ))}
    </div>
  </details>
)}

{years.length > 0 && (
  <details class="filter-panel__section" data-filter-section="years" open={selectedYears.length > 0}>
    <summary class="filter-panel__summary">
      <span>Years</span>
      <span
        class="filter-panel__summary-count"
        data-filter-count="years"
        hidden={selectedYears.length === 0}
      >
        {selectedYears.length > 0 ? selectedYears.length : ''}
      </span>
    </summary>
    <div class="filter-panel__options filter-panel__options--inline">
      {years.map((year) => (
        <label class="filter-panel__option">
          <input
            type="checkbox"
            name="year"
            value={String(year)}
            checked={selectedYears.includes(String(year))}
          />
          {year}
        </label>
      ))}
    </div>
  </details>
)}
</form>

<script type="module" is:inline>
  document.addEventListener('DOMContentLoaded', () => {
    /** @type {HTMLFormElement | null} */
    const form = document.getElementById('blog-filters');
    /** @type {HTMLElement | null} */
    const grid = document.querySelector('[data-blog-grid]');
    /** @type {HTMLElement | null} */
    const emptyState = document.querySelector('[data-blog-empty]');

    if (!form || !grid) {
      if (form) {
        form.addEventListener('submit', (event) => event.preventDefault());
      }
      return;
    }

    /**
     * @typedef {{ tags: string[]; authors: string[]; years: string[]; sort: 'newest' | 'oldest' }} Selection
     * @typedef {{ element: HTMLElement; tags: string[]; authors: string[]; year: string; dateValue: number; order: number }} Card
     */

    /**
     * @param {string} value
     * @returns {string[]}
     */
    const safeParseStringArray = (value) => {
      try {
        const parsed = JSON.parse(value);
        if (Array.isArray(parsed)) {
          return parsed.map((item) => String(item).trim()).filter(Boolean);
        }
      } catch {
        // ignore
      }
      return [];
    };

    form.addEventListener('submit', (event) => event.preventDefault());

    /** @type {HTMLElement[]} */
    const cardElements = Array.from(grid.querySelectorAll('[data-blog-card]'));
    /** @type {Card[]} */
    const cards = cardElements.map((element, index) => {
      const dataset = element.dataset;
      const rawTags = dataset.tags ?? '[]';
      const rawAuthors = dataset.authors ?? '[]';
      const year = dataset.year ?? '';
      const dateValue = Number(dataset.date ?? '0');
      const order = Number(dataset.index ?? String(index));

      return {
        element,
        tags: safeParseStringArray(rawTags),
        authors: safeParseStringArray(rawAuthors),
        year: year ? String(year) : '',
        dateValue: Number.isNaN(dateValue) ? 0 : dateValue,
        order: Number.isNaN(order) ? index : order,
      };
    });

    /**
     * @param {Selection} selection
     */
    const updateCountBadges = (selection) => {
      const entries = [
        ['tags', selection.tags.length],
        ['authors', selection.authors.length],
        ['years', selection.years.length],
      ];

      entries.forEach(([key, count]) => {
        const badge = form.querySelector(`[data-filter-count="${key}"]`);
        if (badge instanceof HTMLElement) {
          badge.textContent = count ? String(count) : '';
          badge.hidden = count === 0;
        }
      });
    };

    const applySelection = (selection) => {
      const { tags, authors, years, sort } = selection;
      const sortMultiplier = sort === 'oldest' ? 1 : -1;

      const sortedCards = [...cards].sort((a, b) => {
        const dateDiff = (a.dateValue - b.dateValue) * sortMultiplier;
        if (dateDiff !== 0) return dateDiff;
        return a.order - b.order;
      });

      sortedCards.forEach(({ element }) => {
        grid.appendChild(element);
      });

      let visibleCount = 0;

      cards.forEach((card) => {
        const tagMatch =
          tags.length === 0 ||
          tags.every((tag) => card.tags.includes(tag));
        const authorMatch =
          authors.length === 0 ||
          authors.every((author) => card.authors.includes(author));
        const yearMatch =
          years.length === 0 ||
          (card.year !== '' && years.includes(card.year));

        const isVisible = tagMatch && authorMatch && yearMatch;
        card.element.style.display = isVisible ? '' : 'none';

        if (isVisible) {
          visibleCount += 1;
        }
      });

      if (emptyState) {
        emptyState.hidden = visibleCount !== 0;
      }

      updateCountBadges(selection);
    };

    /**
     * @param {URLSearchParams} params
     * @returns {Selection}
     */
    const selectionFromParams = (params) => ({
      tags: params.getAll('tag').map((value) => value.trim()).filter(Boolean),
      authors: params.getAll('author').map((value) => value.trim()).filter(Boolean),
      years: params.getAll('year').map((value) => value.trim()).filter(Boolean),
      sort: params.get('sort') === 'oldest' ? 'oldest' : 'newest',
    });

    /**
     * @param {Selection} selection
     * @returns {URLSearchParams}
     */
    const paramsFromSelection = (selection) => {
      const params = new URLSearchParams();
      selection.tags.forEach((value) => params.append('tag', value));
      selection.authors.forEach((value) => params.append('author', value));
      selection.years.forEach((value) => params.append('year', value));
      if (selection.sort === 'oldest') {
        params.set('sort', 'oldest');
      } else {
        params.delete('sort');
      }
      return params;
    };

    /**
     * @param {Selection} selection
     */
    const populateFormFromSelection = (selection) => {
      const tagInputs = form.querySelectorAll('input[type="checkbox"][name="tag"]');
      tagInputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          input.checked = selection.tags.includes(input.value);
        }
      });

      const authorInputs = form.querySelectorAll('input[type="checkbox"][name="author"]');
      authorInputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          input.checked = selection.authors.includes(input.value);
        }
      });

      const yearInputs = form.querySelectorAll('input[type="checkbox"][name="year"]');
      yearInputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          input.checked = selection.years.includes(input.value);
        }
      });

      const sortInputs = form.querySelectorAll('input[type="radio"][name="sort"]');
      sortInputs.forEach((input) => {
        if (input instanceof HTMLInputElement) {
          input.checked = input.value === selection.sort;
        }
      });
    };

    /**
     * @returns {Selection}
     */
    const selectionFromForm = () => {
      const data = new FormData(form);
      return {
        tags: data.getAll('tag').map((value) => String(value).trim()).filter(Boolean),
        authors: data.getAll('author').map((value) => String(value).trim()).filter(Boolean),
        years: data.getAll('year').map((value) => String(value).trim()).filter(Boolean),
        sort: data.get('sort') === 'oldest' ? 'oldest' : 'newest',
      };
    };

    /**
     * @param {Selection} selection
     */
    const updateView = (selection) => {
      applySelection(selection);
      const params = paramsFromSelection(selection);
      const queryString = params.toString();
      const newUrl = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
      window.history.replaceState(null, '', newUrl);
    };

    const initialise = () => {
      const initialSelection = selectionFromParams(new URLSearchParams(window.location.search));
      populateFormFromSelection(initialSelection);
      updateView(initialSelection);
    };

    initialise();

    form.addEventListener('change', () => {
      const selection = selectionFromForm();
      updateView(selection);
    });

    const resetButtons = document.querySelectorAll('[data-blog-reset]');
    resetButtons.forEach((button) => {
      if (!(button instanceof HTMLButtonElement)) return;
      button.addEventListener('click', () => {
        form.reset();
        /** @type {Selection} */
        const defaultSelection = { tags: [], authors: [], years: [], sort: 'newest' };
        populateFormFromSelection(defaultSelection);
        updateView(defaultSelection);
      });
    });
  });
</script>

<style>
  .filter-panel {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 0.75rem;
    border-radius: 0.75rem;
    background: var(--sl-color-bg-soft);
  }

  .filter-panel__options {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .filter-panel__options--inline {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 0.35rem 0.5rem;
  }

  .filter-panel__section {
    padding: 0.05rem 0 0.45rem;
  }

  .filter-panel__section + .filter-panel__section {
    margin-top: 0.4rem;
  }

  .filter-panel__summary {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.6rem;
    padding: 0.3rem 0.15rem;
    cursor: pointer;
    font-weight: 600;
    list-style: none;
  }

  .filter-panel__summary::-webkit-details-marker,
  .filter-panel__summary::marker {
    display: none;
  }

  .filter-panel__summary::after {
    content: '';
    flex-shrink: 0;
    width: 0.65rem;
    height: 0.65rem;
    border-right: 2px solid currentColor;
    border-bottom: 2px solid currentColor;
    transform: rotate(-45deg);
    transition: transform 150ms ease;
  }

  .filter-panel__section[open] .filter-panel__summary::after {
    transform: rotate(45deg);
  }

  .filter-panel__summary-count {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-width: 1.3rem;
    height: 1.3rem;
    border-radius: 999px;
    background: var(--sl-color-bg-soft);
    color: var(--sl-color-text-muted);
    font-size: 0.7rem;
    font-weight: 600;
  }

  .filter-panel__section[open] .filter-panel__summary {
    border-bottom: 1px solid var(--sl-color-hairline);
    margin-bottom: 0.3rem;
    padding-bottom: 0.3rem;
  }

  .filter-panel__option {
    display: inline-flex;
    align-items: center;
    gap: 0.3rem;
    font-size: 0.9rem;
    color: var(--sl-color-text);
  }

  .filter-panel__option input {
    accent-color: var(--sl-color-primary);
  }

</style>
